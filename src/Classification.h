/********************************************************************
**                                                                 **
** File   : src/Classification.h                                   **
** Authors: Viktor Richter                                         **
**                                                                 **
**                                                                 **
** GNU LESSER GENERAL PUBLIC LICENSE                               **
** This file may be used under the terms of the GNU Lesser General **
** Public License version 3.0 as published by the                  **
**                                                                 **
** Free Software Foundation and appearing in the file LICENSE.LGPL **
** included in the packaging of this file.  Please review the      **
** following information to ensure the license requirements will   **
** be met: http://www.gnu.org/licenses/lgpl-3.0.txt                **
**                                                                 **
********************************************************************/

#pragma once
#include "ConfusionMatrix.h"
#include "Exception.h"
#include "Group.h"
#include "JsonSerializable.h"
#include "Observation.h"
#include "Timestamp.h"

namespace fformation {

class Classification : public JsonSerializable {
public:
  /**
   * @brief Classification constructs a classification instance from a timestamp
   * and a vector of IdGroups.
   *
   * @param timestamp the timestamp of the corresponding Observation
   * @param groups the groups of persons. unordered. The groups must not be
   * empty.
   */
  Classification(Timestamp timestamp = Timestamp(),
                 const std::vector<IdGroup> &groups = std::vector<IdGroup>());

  const Timestamp &timestamp() const { return _timestamp; }

  const std::vector<IdGroup> &idGroups() const { return _groups; }

  std::vector<Group> createGroups(const Observation &observation,
                                  bool singular = false) const;

  /**
   * @brief calculateDistanceCosts the sum of distance costs of the contained
   * groups.
   * @param observation the observation this classification is derived from.
   * Needed for person information.
   * @param stride the distance btw. a person and its transactional segment.
   * @return sum costs. 0 if empty. 0 if all groups of size 1.
   */
  double calculateDistanceCosts(const Observation &observation,
                                Person::Stride stride) const;

  /**
   * @brief calculateMDLCosts calculates the minimum description length cost.
   *
   * These costs are needed to penalize groups of size 1 which otherwise would
   * be optimal (zero costs). MDL-Costs are mdl_prior * | groups |
   *
   * @param mdl_prior called sigma^2 in the paper. This is the sigma^2 of the
   *        normal probability distribution describing the position of a persons
   *        transactional segment.
   * @return mdl_prior * | groups |
   */
  double calculateMDLCosts(double mdl_prior) const;

  /**
   * @brief calculateVisibilityCosts calculates the sum of the individual
   * visibility costs for all persons.
   *
   * Calculates the center of each persons group and sums the costs that are
   * generated by obstruction through other persons.
   *
   * @param observation must correspond to this classification
   * @param stride the distance btw. a person and its transactional space
   * @return the costs caused by obstructions btw. all persons and their
   * proposed groups.
   */
  double calculateVisibilityCosts(const Observation &observation,
                                  Person::Stride stride) const;

  /**
   * @brief calculateCosts calculates the summed costs of the classification.
   * @param observation must correspond to this classification
   * @param stride the distance btw. a person and its transactional space
   * @param mdl_prior sigma^2 of the normal probability distribution of persons
   *        transactional space
   * @return
   */
  double calculateCosts(const Observation &observation, Person::Stride stride,
                        double mdl_prior) const {
    return calculateDistanceCosts(observation, stride) +
           calculateMDLCosts(mdl_prior) +
           calculateVisibilityCosts(observation, stride);
  }

  /**
   * @brief calculateGroupIntersection calculates how much first intersects with
   * second.
   *
   * The resulting double is the amount of persons assigned to both groups
   * relative to the size of the bigger group.
   *
   * @param first
   * @param second
   * @return result btw. 0 = no overlap and 1 = full overlap.
   *                if any group is empty the result is 0.
   *                otherwise \f$ | intersection | / max(|first|,|second|)\f$
   */
  static double calculateGroupIntersection(const IdGroup &first,
                                           const IdGroup &second);

  /**
   * @brief createConfusionMatrix creates a confusion matrix from this
   * classification and the passed ground_truth.
   * @param ground_truth the correct classification of the same observation.
   * @param threshhold how much groups need to intersect for a true-positive
   * classification @see calculateGroupIntersection
   * @return A confustion matrix with:
   *   true-positive = | groups with intersection > threshold |
   *   false-positive = | ground_truth | - true-positive
   *   true-negative = | persons in singular groups, not in ground truth |
   *   false-negative = | this | - true-positive
   */
  ConfusionMatrix createConfusionMatrix(const Classification &ground_truth,
                                        double threshhold = 1.) const;

  virtual void serializeJson(std::ostream &out) const override {
    out << "{ \"timestamp\": " << _timestamp << ", \"groups\": ";
    serializeIterable(out, _groups);
    out << " }";
  }

private:
  Timestamp _timestamp;
  std::vector<IdGroup> _groups;
};

} // namespace fformation
